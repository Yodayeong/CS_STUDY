## [프로그래머스 / 12977] 소수 만들기

> ###### 문제 설명
>
> 주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 solution 함수를 완성해주세요.
>
> ##### 제한사항
>
> - nums에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다.
> - nums의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다.
>
> ------
>
> ##### 입출력 예
>
> | nums        | result |
> | ----------- | ------ |
> | [1,2,3,4]   | 1      |
> | [1,2,7,6,4] | 4      |
>
> ##### 입출력 예 설명
>
> 입출력 예 #1
> [1,2,4]를 이용해서 7을 만들 수 있습니다.
>
> 입출력 예 #2
> [1,2,4]를 이용해서 7을 만들 수 있습니다.
> [1,4,6]을 이용해서 11을 만들 수 있습니다.
> [2,4,7]을 이용해서 13을 만들 수 있습니다.
> [4,6,7]을 이용해서 17을 만들 수 있습니다.

<br>

**풀이방법**

- 여러개의 조합들을 찾아서, 각 조합들이 소수인지 찾아준다.

<br>

```cpp
//nums 중 3개를 선택해 소수 만들기

//3개씩 더한 합들의 조합들을 구하고
//각 합들이 소수인지 판별

//근데, 시간초과가 나니까 체로 걸러내라

#include <vector>
#include <iostream>
#include <cmath>
using namespace std;

bool isPrime(int n) {
    //1이하의 수는 소수가 아니다.
    if(n <= 1){
        return false;
    }
    for(int i = 2; i <= sqrt(n); i++) {
        //제곱근 범위 내에서 나눠진다면, 소수가 아니다.
        if(n % i == 0) {
            return false;
        }
    }
    return true;
}

int solution(vector<int> nums) {
    int ans = 0;
    
    //중복되는 수가 들어가면 안되므로, i+1, j+1 부터 시작한다.
    for(int i = 0; i < nums.size(); i++) {
        for(int j = i + 1; j < nums.size(); j++) {
            for(int k = j + 1; k < nums.size(); k++) {
                int tmp = nums[i] + nums[j] + nums[k];
                if(isPrime(tmp) == true) {
                    ans++;
                }
            }
        }
    }
    return ans;
}
```

