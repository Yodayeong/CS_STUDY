## [백준 / 2960] 에라토스테네스의 체

> ## 문제
>
> 에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾는 유명한 알고리즘이다.
>
> 이 알고리즘은 다음과 같다.
>
> 1. 2부터 N까지 모든 정수를 적는다.
> 2. 아직 지우지 않은 수 중 가장 작은 수를 찾는다. 이것을 P라고 하고, 이 수는 소수이다.
> 3. P를 지우고, 아직 지우지 않은 P의 배수를 크기 순서대로 지운다.
> 4. 아직 모든 수를 지우지 않았다면, 다시 2번 단계로 간다.
>
> N, K가 주어졌을 때, K번째 지우는 수를 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 N과 K가 주어진다. (1 ≤ K < N, max(1, K) < N ≤ 1000)
>
> ## 출력
>
> 첫째 줄에 K번째 지워진 수를 출력한다.
>
> ## 예제 입력 1
>
> ```
> 7 3
> ```
>
> ## 예제 출력 1
>
> ```
> 6
> ```

<br>

**풀이방법**

- 2부터 N까지 수를 가지는 배열에
- cnt를 담아서 해당 수가 몇 번째에 지워졌는지 표시한다.

<br>

```cpp
#include <iostream>
#include <vector>
using namespace std;

int N, K;
int cnt = 1;
int flag = 0;

int main() {
    cin >> N >> K;
    vector<int> ary(N+1, 0);
    
    //cnt가 K보다 커지기전까지 (K까지만 체크하면 되므로)
    while(true) {
        if(cnt > K) {
            break;
        }
        
        //배열의 2부터 N까지 체크하며,
        for(int i = 2; i <= N; i++) {
            //해당 수가 아직 체크되지 않았고,
            if(ary[i] == 0) {
                //소수가 맞다면 (하나의 수로라도 나눠지면 flag를 1로 바꿔줌)
                for(int k = 2; k < i; k++) {
                    if(i % k == 0) {
                        flag = 1;
                        break;
                    }
                }
                
                //해당 수를 cnt로 몇 번째에 지워졌는지 표시하고, cnt를 증가한다.
                if(flag == 0) {
                    ary[i] = cnt;
                    cnt++;
                    
                    //그리고, 해당 수의 배수들도 체크하고, cnt 증가한다.
                    for(int j = 2; i * j <= N; j++) {
                        if(ary[i * j] == 0) {
                            ary[i * j] = cnt;
                            cnt++;
                        }
                    }
                }
            }
            
        }
    }
    
    //2부터 N까지 돌면서, cnt가 K와 일치하는 수를 출력한다.
    for(int i = 2; i <= N; i++) {
        if(ary[i] == K) {
            cout << i << endl;
        }
    }
}

```

